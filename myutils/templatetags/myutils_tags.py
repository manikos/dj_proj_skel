from re import sub

from urllib.parse import urlparse, urlunparse

from django import template
from django.urls import resolve, reverse, Resolver404, NoReverseMatch
from django.utils.translation import activate
from django.utils.html import format_html
from django.conf import settings

register = template.Library()


@register.simple_tag()
def sitemap_hreflang_url(url):
    """
    We want each url (generated by the sitemap) to include itself along with other translated versions.
    For example: the url "www.my-bsite.com" (el) should include itself along with "www.my-bsite.com/en/" (en)
    and the url "www.my-bsite.com/en/" (en) should include itself along with "www.my-bsite.com" (el).
    This procedure should apply to all urls.
    Google's answer: https://support.google.com/webmasters/answer/2620865?hl=en&ref_topic=2370587
    :param url: string. A fully qualified URL incl the protocol used (i.e https://www.my-bsite.com/aboutus/).
    :return: string.
    """
    # parses the URL given into the RFC 1808 standard (https://tools.ietf.org/html/rfc1808.html):

    # scheme://   netloc/           path    ;parameters  ?query     #fragment
    #   |            |                |          |          |           |
    # |---|   |---------------| |-----------| |------|  |--------|   |-----|
    # https://www.my-bsite.com   /en/aboutus/ ;type=a   ?active=1    #go-to

    parsed_url = urlparse(url)
    relative_path = parsed_url.path

    lang_codes = [lang[0] for lang in settings.LANGUAGES]
    pre_pattern = '|'.join(lang_codes)
    pattern = '^/(%s)' % pre_pattern  # pattern = '^/(en|el|...other language codes)'

    to_return = ''
    xml_tag_template = '<xhtml:link rel="alternate" hreflang="{hreflang}" href="{href}" />'

    # strip from the beginning any potential language code, so `reverse()` should work with the LANGUAGE_CODE
    bare_url = sub(pattern, '', relative_path)  # i.e "/" or "/aboutus/" or "/jewelry/earrings/product/earring-1"
    activate(settings.LANGUAGE_CODE)
    # try to get the resolver object that matched the URL. Fail that, return None.
    # Will always work since we stripped lang code and inside the root URLconf we have `prefix_default_language=False`
    try:
        resolver_match = resolve(bare_url)
    except Resolver404:
        return

    for lang_code in lang_codes:
        activate(lang_code)
        try:
            path = reverse(resolver_match.url_name, args=resolver_match.args, kwargs=resolver_match.kwargs)
        except NoReverseMatch:
            pass
        else:
            # rebuild the url using the 6 parts that urlparse() created at start.
            href = urlunparse([parsed_url.scheme, parsed_url.netloc, path,
                               parsed_url.params, parsed_url.query, parsed_url.fragment])
            to_return += xml_tag_template.format(hreflang=lang_code, href=href)

    return format_html(to_return)


@register.simple_tag()
def list_dict_items(dict_iterable):
    """
    NOT USED ANYWHERE
    Converts an iterable (which may contain other iterables) to a list. In other words, flattens a list.
    :param dict_iterable: an iterable
    :return: a list
    """
    return [item[0] if isinstance(item, list) else item for item in dict_iterable]
